{"name":"Pojocss","tagline":"Exploring the power Plain ol' Javascript Objects could bring to building stylesheets.","body":"#POJOCSS.js\r\n\r\nDon't be confused.  This is a Javascript library for building CSS files.  Yes, I know:  \"What?\"\r\n\r\nThis is about exploring what expressing CSS rulesets as Plain ol' Javascript Objects could bring to the experience of building stylesheets for your webapps.\r\n\r\nLet's see what I've found so far\r\n\r\n##Module System\r\n\r\nWe are smart authors of CSS, we like to namespace our classes and not fight the specificity battle.  So, we develop our styles in modules.  One powerful thing that I've found here?  We can compose a lot of different ways to compose our rule selectors.  For instance:\r\n\r\n    ``` css\r\n    .module-class  { ... }\r\n    .module--class { ... }\r\n    .module_class  { ... }\r\n    .module__class { ... }\r\n    .module .class { ... }\r\n    ```\r\n\r\nNo need for the system to get all opinionated, though it does start with one big opinion that may be a deal breaker for some.  *All* selectors are classes. So the module name will either add it self to the front(or rear maybe) of the class names you choose as selectors.  One flag changes everything.  This makes the module system lightweight.\r\n\r\n``` javascript\r\npojocss.module('moduleName', {\r\n\t'class': {\r\n\t\t'property': 'value';\r\n\t},\r\n\t'class2': {\r\n\t\t'other-property': 'other-value'\r\n\t}\r\n}, 'du').build();\r\n```\r\n\r\nYou'll see that you supply a string name for the module, an object containing key-value pairs of class names and declaration blocks expressed as key-value pairs, and then finally a display options object that allows you to choose how the classes are rendered: `h`, `dh`, `u`, `du`, `no`, or `id`.  These stand for hyphen, double-hyphen, underscore, double-underscore, no module name, and indirect descendant syntax.  If you write low specificity, class-based stylesheets, and want to componentize your rules easily, this is a great tool.\r\n\r\nBut surely namespacing isn't the advantage to a module system is it?  Of course not.\r\n\r\n##Cross-module inheritance\r\n\r\nRulesets(or 'classes' as they are referred to here multiple times) can directly inherit from rulesets in other modules.  See the following.\r\n\r\n``` javascript\r\npojocss.module('firstModule', {\r\n\t'class': {\r\n\t\t'property': 'value';\r\n\t},\r\n\t'class2': {\r\n\t\t'other-property': 'other-value'\r\n\t}\r\n}, 'du').build();\r\n\r\npojocss.module('secondModule', {\r\n\t'class1 < firstModule.class2': {\r\n\t\t'some-property': 'some-value'\r\n\t}\r\n}, 'du').build();\r\n```\r\n\r\nNow, when a graph of `[firstModule, secondModule]` is rendered, `secondModule.class1` will look like this\r\n\r\n``` css\r\n.second-module__class1 {\r\n\tsome-property: some-value,\r\n\tother-property: other-value\r\n}\r\n```\r\n\r\nNow, this seems like a mixin sort of.  How can it be more powerful, just a light coat of DSL.\r\n\r\n##Lightweight DSL for abstract classes and implicit override protection\r\n\r\nNeed a class to be \"abstract\" or exact to fulfill dependencies, but not actually appear in the rendered stylesheets? When you create the selector key for the ruleset, just prefix it with a `*`, like so:\r\n\r\n``` javascript\r\n{\r\n\t'*abstractClass': {\r\n\t\t'some-property': 'some-value'\r\n\t}\r\n}\r\n```\r\n\r\nAnything that extends that class will be able to do so, but this ruleset will not be found in your CSS file.  Now, I said this DSL was lightweight, and it in fact has one other operator: `!`.  Place it in front a property name to make it explicit that you wish to override the value from a dependency.  Failing to do so will cause the compiler to throw an error.  This way, with low specificity and only class based styles, you can easily author styles without calculating specificity scores or accidentally overwriting properties.  Do it like this:\r\n\r\n``` javascript\r\npojocss.module('firstModule', {\r\n\t'class': {\r\n\t\t'property': 'value';\r\n\t},\r\n\t'class2': {\r\n\t\t'other-property': 'other-value'\r\n\t}\r\n}, 'du').build();\r\n\r\npojocss.module('secondModule', {\r\n\t'class1 < firstModule.class2': {\r\n\t\t'!other-property': 'some-other-value'\r\n\t}\r\n}, 'du').build();\r\n```\r\n And you'll end up with this:\r\n\r\n ``` css\r\n.second-module__class1 {\r\n\tother-property: some-other-value\r\n}\r\n```\r\n\r\n##It's just Javascript\r\n\r\nProbably the best part about *POJOCSS* is that it is _just Javascript_, not some CSS variant trying to hack on calculation and variables and such.  This is what Javascript does for a living.  Create variables, generators, factory functions, value calculators, whatever you'd like.  Or use it like it's just a preprocessor.  Or use it like PostCSS, scanning properties and values for things to transform, combine, or divide.  Auto-prefix with ease.\r\n\r\nRight now, there aren't any \"hooks\" into the compilation system.  But there might not need to be.  There are two great places for you to put your hacking skills to work.\r\n\r\n###Defining the classes\r\n\r\n######Coming Soon...\r\n\r\n###Working with built modules\r\n\r\n######Coming Soon...\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}